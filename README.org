#+TITLE: TScript41 Spec

Implementation can be part of TScript34, even of TScript34-P0019.
Want a name that is separate because it could be embedded
in other projects.

- [X] Come up with name
  - TOGSOFT-whatever is fine
  - "TOGSOFT-41" or "TScript41"
- [X] Make a repo for it
  - [[https://github.com/TOGoS/TScript41]]
- [/] Document syntax
  - Sketched out [[#syntax-examples][below]]
- [ ] Write some test cases

** Ideas

Simplified from TCL or Bash:
- No `uplevel`
- Simplified tokenization rules

'Everything is a string' because out in the 'real world' byte sequences are the lowest common denominator.
So let's make 'how to interpret this string' explicit
and conversions very easy.  Interpretations can be cached.

(Actually, everything is a stream of bytes.
But finite, pre-generated byte streams are the building blocks for scripts.)

Functions act as if they launch processes.
Process can do I/O and return an exit code.
Normal 'result' of a procuss is what it writes to stdout.
Can wrap a command with some 'run and return exit code'

I'd like the syntax and semantics to be cleanly seperable.
e.g. ~"foo ${bar}"~ and ~(cat data:,foo env:bar)~ may be equivalent.

Long names for built-in commands.
Can be aliased, similar to in TS34.

The language is relatively 'stateless';
variables (which are equivalent to environment variables)
do not change value within a block.
They can only be overridden for a particular scope.

Like with shell scripting, environment variables and commands are separate namespaces.

** Basic Syntax

'#' followed directly by non-whitespace is a tokenizer/parser directive.

'#' followed by whitespace starts a line comment.
'#' can be used after non-comment tokens.

Newline can be considered a token, equivalent to ';'

\' token means, for statement-parsing purposes, skip all following newline and '#' tokens,
with the effect of continuing the preceding statement.

Tokens can be barewords, double-quoted or brace-enclosed strings,
or variable or sub-expression references (started with '$').


** Syntax Examples
:PROPERTIES:
:CUSTOM_ID: syntax-examples
:END:

#+begin_src ts41
#lang tscript41
#{
	A block comment.  Really a variation on '{' where the token is skipped over.
	#{
		Block comments can be nested.
	}
}
http://ns.nuke24.net/TScript41/Commands/WithCommandAliases {
	{echo http://ns.nuke24.net/TScript41/Commands/Echo}
	{with-aliases http://ns.nuke24.net/TScript41/Commands/WithCommandAliases}
	{with-env http://ns.nuke24.net/TScript41/Commands/WithEnv}
} $#REST
"foo ${var} $(expression) \n" # Double-quoted strings allow for variable/expression substituion and backslash escapes
{literal {nestable} quoting style} # Curly braces work like in Tcl
echo $(expression) # can use $ outside of quoted strings; they become a single argument
echo $variable # don't need '{}' outside of quoted strings
echo $*variable # '$*' instead of '$' means 'splat' the variable or expression result.
echo $*{variable} # Same
echo $*(echo foo bar baz) # equivalent to `echo foo bar baz`
echo ${foo}"bar" # NOT ALLOWED!  If you want concatenation, use double-quoted strings.
foo="bar" baz="quux" {echo $foo} # set variables and run a command (same as JCR36)
foo="bar" $#REST # with foo=bar, execute the rest of the current block
#+end_src
